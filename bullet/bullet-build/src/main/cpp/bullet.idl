[NoDelete]
interface CustomCode {
    static long GetBTVersion();
};

[Prefix = "btCollisionWorld::"]
interface ContactResultCallback {
    float addSingleResult([Ref]btManifoldPoint cp, [Const]btCollisionObjectWrapper colObj0Wrap, long partId0, long index0, [Const]btCollisionObjectWrapper colObj1Wrap, long partId1, long index1);
    boolean needsCollision(btBroadphaseProxy proxy0);
};

[NoDelete]
interface btCollisionObjectWrapper {
};

interface btVector3 {
    void btVector3();
    void btVector3(float x, float y, float z);
    float length();
    float getX();
    float getY();
    float getZ();
    void setX(float x);
    void setY(float y);
    void setZ(float z);
    void setValue(float x, float y, float z);
};

interface btQuadWord {
    float getX();
    float getY();
    float getZ();
    void setX(float x);
    void setY(float y);
    void setZ(float z);
    void setW(float w);
};

interface btQuaternion {
    void btQuaternion();
    void btQuaternion(float x, float y, float z, float w);
    void setValue(float x, float y, float z, float w);
    void setEulerZYX(float z, float y, float x);
    void setRotation([Const, Ref] btVector3 axis, float angle);
    float getW();
    void normalize();
};
btQuaternion implements btQuadWord;

interface btMatrix3x3 {
    void btMatrix3x3();
    void setEulerZYX(float ex, float ey, float ez);
    void getRotation([Ref]btQuaternion q);
    [Operator="[]", Ref] btVector3 getRow(long i);
    [Value]btVector3 getColumn(long y);
};

interface btTransform {
    void btTransform();
    void btTransform([Ref]btQuaternion q, [Ref]btVector3 v);
    void setIdentity();
    void setOrigin([Ref]btVector3 origin);
    void setRotation([Ref]btQuaternion rotation);
    [Ref]btVector3 getOrigin();
    [Value]btQuaternion getRotation();
    [Ref]btMatrix3x3 getBasis();
    void setFromOpenGLMatrix(float[] m);
    void getOpenGLMatrix(float[] m);
};

interface btMotionState {
};

[JSImplementation="btMotionState"]
interface MotionStateImpl {
    void MotionStateImpl();
    [Const] void getWorldTransform([Ref]btTransform worldTrans);
    void setWorldTransform([Const, Ref]btTransform worldTrans);
};

interface btIDebugDraw {};

[JSImplementation="btIDebugDraw"]
interface DebugDrawImpl {
    void DebugDrawImpl();
    void drawLine([Const, Ref] btVector3 vecFrom, [Const, Ref] btVector3 vecTo, [Const, Ref] btVector3 color);
    void drawContactPoint([Const, Ref] btVector3 PointOnB, [Const, Ref] btVector3 normalOnB, float distance, long lifeTime, [Const, Ref] btVector3 color);
    void reportErrorWarning([Const] DOMString warningString);
    void draw3dText([Const, Ref] btVector3 location, [Const] DOMString textString);
    void setDebugMode(long debugMode);
    [Const] long getDebugMode();
};

// Collision

interface btCollisionWorld {
    void btCollisionWorld(btDispatcher dispatcher, btBroadphaseInterface pairCache, btCollisionConfiguration collisionConfiguration);
    void setBroadphase(btBroadphaseInterface pairCache);
    btBroadphaseInterface getBroadphase();
    btOverlappingPairCache getPairCache();
    btDispatcher getDispatcher();
    [Ref]btDispatcherInfo getDispatchInfo();
    btIDebugDraw getDebugDrawer();
    void updateSingleAabb(btCollisionObject colObj);
    void updateAabbs();
    void computeOverlappingPairs();
    void setDebugDrawer(btIDebugDraw debugDrawer);
    void debugDrawWorld();
    void debugDrawObject ([Const, Ref] btTransform worldTransform, [Const] btCollisionShape shape, [Const, Ref] btVector3 color);
    long getNumCollisionObjects();
    void rayTest([Const, Ref]btVector3 rayFromWorld, [Const, Ref]btVector3 rayToWorld, [Ref]RayResultCallback resultCallback);
    void convexSweepTest([Const]btConvexShape castShape, [Const, Ref]btTransform from, [Const, Ref]btTransform to, [Ref]ConvexResultCallback resultCallback, optional float allowedCcdPenetration);
    void contactTest(btCollisionObject colObj, [Ref]ContactResultCallback resultCallback);
    void contactPairTest(btCollisionObject colObjA, btCollisionObject colObjB, [Ref]ContactResultCallback resultCallback);
    void addCollisionObject(btCollisionObject collisionObject, optional long collisionFilterGroup, optional long collisionFilterMask);
    [Ref]btCollisionObjectArray getCollisionObjectArray();
    void removeCollisionObject(btCollisionObject collisionObject);
    void performDiscreteCollisionDetection();
    boolean getForceUpdateAllAabbs ();
    void setForceUpdateAllAabbs(boolean f);
};

interface btCollisionConfiguration {};

interface btDefaultCollisionConstructionInfo {
    void btDefaultCollisionConstructionInfo();
};

interface btDefaultCollisionConfiguration {
    void btDefaultCollisionConfiguration([Ref]optional btDefaultCollisionConstructionInfo info);
};
btDefaultCollisionConfiguration implements btCollisionConfiguration;

interface btCollisionObject {
    void btCollisionObject();
    btCollisionShape getCollisionShape();
    boolean mergesSimulationIslands();
    [Const, Ref] btVector3 getAnisotropicFriction();
    void setAnisotropicFriction([Const, Ref]btVector3 anisotropicFriction, long frictionMode);
    boolean hasAnisotropicFriction(optional long frictionMode);
    void setContactProcessingThreshold(float contactProcessingThreshold);
    float getContactProcessingThreshold();
    boolean isStaticObject();
    boolean isKinematicObject();
    boolean isStaticOrKinematicObject();
    boolean hasContactResponse();
    void setCollisionShape(btCollisionShape collisionShape);
    void setIgnoreCollisionCheck([Const] btCollisionObject obj, boolean ignoreCollisionCheck);
    boolean checkCollideWithOverride([Const] btCollisionObject obj);
    long getActivationState();
    void setActivationState(long newState);
    void setDeactivationTime(float time);
    float getDeactivationTime();
    void forceActivationState(long newState);
    void activate(optional boolean forceActivation);
    boolean isActive();
    void setRestitution(float rest);
    float getRestitution();
    void setFriction(float frict);
    float getFriction();
    void setRollingFriction(float frict);
    float getRollingFriction();
    [Ref]btTransform getWorldTransform();
    void setWorldTransform([Const, Ref]btTransform worldTrans);
    btBroadphaseProxy getBroadphaseHandle();
    void setBroadphaseHandle(btBroadphaseProxy handle);
    [Ref] btTransform getInterpolationWorldTransform();
    void setInterpolationWorldTransform([Const, Ref]btTransform trans);
    void setInterpolationLinearVelocity([Const, Ref]btVector3 linvel);
    void setInterpolationAngularVelocity([Const, Ref]btVector3 angvel);
    [Const, Ref]btVector3 getInterpolationLinearVelocity();
    [Const, Ref]btVector3 getInterpolationAngularVelocity();
    long getIslandTag();
    void setIslandTag(long tag);
    long getCompanionId();
    void setCompanionId(long id);
    float getHitFraction();
    void setHitFraction(float hitFraction);
    long getCollisionFlags();
    void setCollisionFlags(long flags);
    float getCcdSweptSphereRadius();
    void setCcdSweptSphereRadius(float radius);
    float getCcdMotionThreshold();
    float getCcdSquareMotionThreshold();
    void setCcdMotionThreshold(float ccdMotionThreshold);
    any getUserPointer();
    long getUserIndex();
    void setUserPointer(any userPointer);
    void setUserIndex(long index);
    long getUpdateRevisionInternal();
    boolean checkCollideWith([Const] btCollisionObject co);
    [Const] long getInternalType();
};

interface btManifoldPoint {
    [Const, Ref]btVector3 getPositionWorldOnA();
    [Const, Ref]btVector3 getPositionWorldOnB();
    float getAppliedImpulse();
    float getDistance();
    [Value]attribute btVector3 m_localPointA;
    [Value]attribute btVector3 m_localPointB;
    [Value]attribute btVector3 m_positionWorldOnB;
    [Value]attribute btVector3 m_positionWorldOnA;
    [Value]attribute btVector3 m_normalWorldOnB;
    long getLifeTime();
};

interface btBroadphaseProxy {};

interface btPersistentManifold {
    void btPersistentManifold();
    [Const]btCollisionObject getBody0();
    [Const]btCollisionObject getBody1();
    long getNumContacts();
    [Ref]btManifoldPoint getContactPoint(long index);
};

interface btDispatcher {
    long getNumManifolds();
    btPersistentManifold getManifoldByIndexInternal(long index);
};

interface btCollisionDispatcher {
    void btCollisionDispatcher(btCollisionConfiguration conf);
};
btCollisionDispatcher implements btDispatcher;

interface btOverlappingPairCallback {};

interface btCollisionAlgorithm {
    void getAllContactManifolds([Ref]btManifoldArray manifoldArray);
};

interface btBroadphasePair {
    attribute btCollisionAlgorithm m_algorithm;
};

interface btOverlappingPairCache {
    void setInternalGhostPairCallback(btOverlappingPairCallback ghostPairCallback);
    [Ref]btBroadphasePairArray getOverlappingPairArray();
};

interface btBroadphaseInterface {
    btOverlappingPairCache getOverlappingPairCache();
};

interface btDbvtBroadphase {
    void btDbvtBroadphase();
};
btDbvtBroadphase implements btBroadphaseInterface;

interface btManifoldArray {
    void btManifoldArray();
    [Const]long size();
    [Const]btPersistentManifold at(long n);
    void resize(long value);
    long capacity();
};

interface btBroadphasePairArray {
    [Const]long size();
    [Const, Ref]btBroadphasePair at(long n);
    void resize(long value);
    long capacity();
};

interface btCollisionShape {
    void setLocalScaling([Const, Ref]btVector3 scaling);
    void calculateLocalInertia(float mass, [Ref]btVector3 inertia);
    void setMargin(float margin);
    float getMargin();
    long getShapeType();
    void getAabb([Const, Ref]btTransform t, [Ref]btVector3 aabbMin, [Ref]btVector3 aabbMax);
    boolean isPolyhedral();
    boolean isConvex2d();
    boolean isConvex();
    boolean isNonMoving();
    boolean isConcave();
    boolean isCompound();
    boolean isSoftBody();
    boolean isInfinite();
};

interface btConvexShape {
    long getNumPreferredPenetrationDirections();
    void getPreferredPenetrationDirection(long index, [Ref]btVector3 penetrationVector);
};
btConvexShape implements btCollisionShape;

interface btConvexInternalShape {
    void setImplicitShapeDimensions([Ref]btVector3 dimensions);
};
btConvexInternalShape implements btConvexShape;

interface btPolyhedralConvexShape {
};
btPolyhedralConvexShape implements btConvexInternalShape;

interface btBoxShape {
    void btBoxShape([Ref]btVector3 boxHalfExtents);
    void setMargin(float margin);
    [Ref,Const] btVector3 getHalfExtentsWithoutMargin();
    float getMargin();
};
btBoxShape implements btPolyhedralConvexShape;


[Prefix = "btRigidBody::"]
interface btRigidBodyConstructionInfo {
    void btRigidBodyConstructionInfo(float mass, btMotionState motionState, btCollisionShape collisionShape, [Ref]optional btVector3 localInertia);
    attribute float m_linearDamping;
    attribute float m_angularDamping;
    attribute float m_friction;
    attribute float m_rollingFriction;
    attribute float m_restitution;
    attribute float m_linearSleepingThreshold;
    attribute float m_angularSleepingThreshold;
    attribute boolean m_additionalDamping;
    attribute float m_additionalDampingFactor;
    attribute float m_additionalLinearDampingThresholdSqr;
    attribute float m_additionalAngularDampingThresholdSqr;
    attribute float m_additionalAngularDampingFactor;
};

interface btRigidBody {
    void btRigidBody([Const, Ref]btRigidBodyConstructionInfo constructionInfo);
    void btRigidBody (float mass, btMotionState motionState, btCollisionShape collisionShape, [Const, Ref] optional btVector3 localInertia);
    attribute long m_contactSolverType;
    attribute long m_frictionSolverType;
    void proceedToTransform([Const, Ref]btTransform newTrans);
    void predictIntegratedTransform(float step, [Ref]btTransform predictedTransform);
    void saveKinematicState(float step);
    void applyGravity();
    void setGravity([Const, Ref]btVector3 acceleration);
    [Const, Ref]btVector3 getGravity();
    void setDamping(float lin_damping, float ang_damping);
    float getLinearDamping();
    float getAngularDamping();
    float getLinearSleepingThreshold();
    float getAngularSleepingThreshold();
    void applyDamping(float timeStep);
    void setMassProps(float mass, [Const, Ref]btVector3 inertia);
    [Const, Ref]btVector3 getLinearFactor();
    void setLinearFactor([Const, Ref]btVector3 linearFactor);
    float getInvMass();
    [Const,Ref]btMatrix3x3 getInvInertiaTensorWorld();
    void integrateVelocities(float step);
    void setCenterOfMassTransform([Const, Ref]btTransform xform);
    void applyCentralForce([Const, Ref]btVector3 force);
    [Const, Ref]btVector3 getTotalForce();
    [Const, Ref]btVector3 getTotalTorque();
    [Const, Ref]btVector3 getInvInertiaDiagLocal();
    void setInvInertiaDiagLocal([Const,Ref]btVector3 diagInvInertia);
    void setSleepingThresholds(float linear, float angular);
    void applyTorque([Const, Ref]btVector3 torque);
    void applyForce([Const, Ref]btVector3 force, [Const, Ref]btVector3 rel_pos);
    void applyCentralImpulse([Const, Ref]btVector3 impulse);
    void applyTorqueImpulse([Const, Ref]btVector3 torque);
    void applyImpulse([Const, Ref]btVector3 impulse, [Const, Ref]btVector3 rel_pos);
    void clearForces();
    void updateInertiaTensor();
    [Const, Ref]btVector3 getCenterOfMassPosition();
    [Const, Ref]btTransform getCenterOfMassTransform();
    [Const, Ref]btVector3 getLinearVelocity();
    [Const, Ref]btVector3 getAngularVelocity();
    void setLinearVelocity([Const, Ref]btVector3 lin_vel);
    void setAngularVelocity([Const, Ref]btVector3 ang_vel);
    void translate([Const, Ref]btVector3 trs);
    void getAabb([Ref]btVector3 aabbMin, [Ref]btVector3 aabbMax);
    float computeImpulseDenominator([Const, Ref]btVector3 pos, [Const, Ref]btVector3 normal);
    float computeAngularImpulseDenominator([Const, Ref]btVector3 axis);
    void updateDeactivation(float timeStep);
    boolean wantsSleeping();
    //btBroadphaseProxy getBroadphaseProxy(); // Not needed. btCollisionObject already have this call
    //void setNewBroadphaseProxy(btBroadphaseProxy broadphaseProxy) // Not needed
    btMotionState getMotionState();
    void setMotionState(btMotionState motionState);
    void setAngularFactor([Const, Ref]btVector3 angFac);
    [Const, Ref]btVector3 getAngularFactor();
    boolean isInWorld();
    void addConstraintRef(btTypedConstraint c);
    void removeConstraintRef(btTypedConstraint c);
    btTypedConstraint getConstraintRef(long index);
    long getNumConstraintRefs();
    void setFlags(long flags);
    long getFlags();
    [Value]btQuaternion getOrientation();
    [Value]btVector3 getVelocityInLocalPoint([Const, Ref]btVector3 rel_pos);
    [Value]btVector3 computeGyroscopicImpulseImplicit_World(float dt);
    [Value]btVector3 computeGyroscopicImpulseImplicit_Body(float step);
    [Value]btVector3 computeGyroscopicForceExplicit(float maxGyroscopicForce);
    [Value]btVector3 getLocalInertia();
};
btRigidBody implements btCollisionObject;

interface btTypedConstraint {
    void enableFeedback(boolean needsFeedback);
    [Const]float getBreakingImpulseThreshold();
    void setBreakingImpulseThreshold([Const]float threshold);
    [Const, Ref]btRigidBody getRigidBodyA();
    [Const, Ref]btRigidBody getRigidBodyB();
};

interface btSequentialImpulseConstraintSolver {
    void btSequentialImpulseConstraintSolver();
};
btSequentialImpulseConstraintSolver implements btConstraintSolver;

interface btConstraintSolver {};

interface btContactSolverInfo {
    attribute boolean m_splitImpulse;
    attribute long m_splitImpulsePenetrationThreshold;
};

interface btDynamicsWorld {
    long stepSimulation(float timeStep, optional long maxSubSteps, optional float fixedTimeStep);
    void addAction(btActionInterface action);
    void removeAction(btActionInterface action);
    [Ref]btContactSolverInfo getSolverInfo();
    void addRigidBody(btRigidBody body);
    void addRigidBody(btRigidBody body, long group, long mask);
    void removeRigidBody(btRigidBody body);
    void setGravity([Ref]btVector3 gravity);
    [Value]btVector3 getGravity();
    void addConstraint(btTypedConstraint constraint, optional boolean disableCollisionsBetweenLinkedBodies);
    void removeConstraint(btTypedConstraint constraint);
    void clearForces();
};
btDynamicsWorld implements btCollisionWorld;

interface btDiscreteDynamicsWorld {
    void btDiscreteDynamicsWorld(btDispatcher dispatcher, btBroadphaseInterface pairCache, btConstraintSolver constraintSolver, btCollisionConfiguration collisionConfiguration);
};
btDiscreteDynamicsWorld implements btDynamicsWorld;

interface btActionInterface {
    void updateAction(btCollisionWorld collisionWorld, float deltaTimeStep);
    void debugDraw(btIDebugDraw debugDrawer);
};

// Custom Glue
//
//interface MybtTriangleRaycastCallback {
//    void MybtTriangleRaycastCallback([Const, Ref]btVector3 from, [Const, Ref]btVector3 to, optional long flags);
//    float reportHit([Const, Ref]btVector3 hitNormalLocal, float hitFraction, long partId, long triangleIndex);
//};
//MybtTriangleRaycastCallback implements btTriangleRaycastCallback;
//
//interface MyMotionState {
//    void MyMotionState();
//};
//MyMotionState implements btMotionState;
//

//interface MyTemp {
//    [Value]btVector3 btVec3_1(float x, float y, float z);
//    [Value]btVector3 btVec3_2(float x, float y, float z);
//    [Value]btQuaternion btQuat();
//    [Value]btTransform btTran();
//    [Value]btMatrix3x3 btMat3();
//};

interface btConstCollisionObjectArray {
    void btConstCollisionObjectArray();
    [Const] long size();
    [Const] btCollisionObject at(long n);
    void resize(long value);
    long capacity();
};

interface btVector3Array {
    void btVector3Array();
    [Const] long size();
    [Value] btVector3 at(long n);
    void resize(long value);
    long capacity();
};

interface btScalarArray {
    void btScalarArray();
    [Const] long size();
    float at(long n);
    void resize(long value);
    long capacity();
};

//interface MyClosestRayResultCallback {
//    void MyClosestRayResultCallback([Const, Ref] btVector3 from, [Const, Ref] btVector3 to);
//    float addSingleResult([Ref] LocalRayResult rayResult, boolean normalInWorldSpace);
//    float addSingleResultSuper([Ref] LocalRayResult rayResult, boolean normalInWorldSpace);
//};
//MyClosestRayResultCallback implements ClosestRayResultCallback;
//
//interface MyAllHitsRayResultCallback {
//    void MyAllHitsRayResultCallback([Const, Ref] btVector3 from, [Const, Ref] btVector3 to);
//    float addSingleResult([Ref] LocalRayResult rayResult, boolean normalInWorldSpace);
//    float addSingleResultSuper([Ref] LocalRayResult rayResult, boolean normalInWorldSpace);
//};
//MyAllHitsRayResultCallback implements AllHitsRayResultCallback;
//
//
//interface MyRayResultCallback {
//    void MyRayResultCallback();
//    float addSingleResult([Ref] LocalRayResult rayResult, boolean normalInWorldSpace);
//};
//MyRayResultCallback implements RayResultCallback;
//

//[JSImplementation="ContactResultCallback"]
//interface ConcreteContactResultCallback {
//    void ConcreteContactResultCallback();
//    float addSingleResult([Ref] btManifoldPoint cp, [Const] btCollisionObjectWrapper colObj0Wrap, long partId0, long index0, [Const] btCollisionObjectWrapper colObj1Wrap, long partId1, long index1);
//};
//
//// Linear Math
//


[Prefix = "btCollisionWorld::"]
interface LocalRayResult {
    [Const]attribute btCollisionObject m_collisionObject;
    attribute LocalShapeInfo m_localShapeInfo;
    [Value]attribute btVector3 m_hitNormalLocal;
    attribute float m_hitFraction;
};

[Prefix = "btCollisionWorld::"]
interface RayResultCallback {
    // abstract base class, no constructor
    boolean hasHit();
    attribute float m_closestHitFraction;
    attribute long m_collisionFilterGroup;
    attribute long m_collisionFilterMask;
    [Const]attribute btCollisionObject m_collisionObject;
    attribute unsigned long m_flags;
    float addSingleResult([Ref]LocalRayResult rayResult, boolean normalInWorldSpace);
};

[Prefix = "btCollisionWorld::"]
interface ClosestRayResultCallback {
    void ClosestRayResultCallback([Const, Ref]btVector3 from, [Const, Ref]btVector3 to);
    [Value]attribute btVector3 m_rayFromWorld;
    [Value]attribute btVector3 m_rayToWorld;
    [Value]attribute btVector3 m_hitNormalWorld;
    [Value]attribute btVector3 m_hitPointWorld;
};
ClosestRayResultCallback implements RayResultCallback;

[Prefix = "btCollisionWorld::"]
interface AllHitsRayResultCallback {
    void AllHitsRayResultCallback([Const, Ref]btVector3 from, [Const, Ref]btVector3 to);
    [Value]attribute btConstCollisionObjectArray m_collisionObjects;
    [Value]attribute btVector3 m_rayFromWorld;
    [Value]attribute btVector3 m_rayToWorld;
    [Value]attribute btVector3Array m_hitNormalWorld;
    [Value]attribute btVector3Array m_hitPointWorld;
    [Value]attribute btScalarArray m_hitFractions;
};
AllHitsRayResultCallback implements RayResultCallback;

[Prefix = "btCollisionWorld::"]
interface LocalShapeInfo {
    attribute long m_shapePart;
    attribute long m_triangleIndex;
};

[Prefix = "btCollisionWorld::"]
interface LocalConvexResult {
    void LocalConvexResult([Const]btCollisionObject hitCollisionObject, LocalShapeInfo localShapeInfo, [Const, Ref]btVector3 hitNormalLocal, [Const, Ref]btVector3 hitPointLocal, float hitFraction);
    [Const]attribute btCollisionObject m_hitCollisionObject;
    attribute LocalShapeInfo m_localShapeInfo;
    [Value]attribute btVector3 m_hitNormalLocal;
    [Value]attribute btVector3 m_hitPointLocal;
    attribute float m_hitFraction;
};

[Prefix = "btCollisionWorld::"]
interface ConvexResultCallback {
    // abstract base class, no constructor
    boolean hasHit();
    attribute long m_collisionFilterGroup;
    attribute long m_collisionFilterMask;
    attribute float m_closestHitFraction;
};

[Prefix = "btCollisionWorld::"]
interface ClosestConvexResultCallback {
    void ClosestConvexResultCallback([Const, Ref]btVector3 convexFromWorld, [Const, Ref]btVector3 convexToWorld);
    [Value]attribute btVector3 m_convexFromWorld;
    [Value]attribute btVector3 m_convexToWorld;
    [Value]attribute btVector3 m_hitNormalWorld;
    [Value]attribute btVector3 m_hitPointWorld;
};
ClosestConvexResultCallback implements ConvexResultCallback;

interface btGearConstraint {
    void btGearConstraint([Ref]btRigidBody rbA, [Ref]btRigidBody rbB, [Const, Ref]btVector3 axisInA, [Const, Ref]btVector3 axisInB, optional float ratio);
};

interface btAxisSweep3 {
    void btAxisSweep3([Ref]btVector3 worldAabbMin, [Ref]btVector3 worldAabbMax, optional long maxHandles, optional btOverlappingPairCache pairCache, optional boolean disableRaycastAccelerator);
};
btAxisSweep3 implements btBroadphaseInterface;

// Arrays

interface btCollisionObjectArray {
    [Const]long size();
    [Const]btCollisionObject at(long n);
    void resize(long value);
    long capacity();
};

interface btStridingMeshInterface {};

interface btPolyhedralConvexAabbCachingShape {
};
btPolyhedralConvexAabbCachingShape implements btPolyhedralConvexShape;

interface btConvexTriangleMeshShape {
    void btConvexTriangleMeshShape(btStridingMeshInterface meshInterface, optional boolean calcAabb);
};
btConvexTriangleMeshShape implements btPolyhedralConvexAabbCachingShape;

interface btCapsuleShape {
    void btCapsuleShape(float radius, float height);
    void setMargin(float margin);
    float getMargin();
};
btCapsuleShape implements btConvexInternalShape;

interface btCapsuleShapeX {
    void btCapsuleShapeX(float radius, float height);
    void setMargin(float margin);
    float getMargin();
};
btCapsuleShapeX implements btCapsuleShape;

interface btCapsuleShapeZ {
    void btCapsuleShapeZ(float radius, float height);
    void setMargin(float margin);
    float getMargin();
};
btCapsuleShapeZ implements btCapsuleShape;

interface btCylinderShape {
    void btCylinderShape([Ref]btVector3 halfExtents);
    void setMargin(float margin);
    float getMargin();
};
btCylinderShape implements btConvexInternalShape;

interface btCylinderShapeX {
    void btCylinderShapeX([Ref]btVector3 halfExtents);
    void setMargin(float margin);
    float getMargin();
};
btCylinderShapeX implements btCylinderShape;

interface btCylinderShapeZ {
    void btCylinderShapeZ([Ref]btVector3 halfExtents);
    void setMargin(float margin);
    float getMargin();
};
btCylinderShapeZ implements btCylinderShape;

interface btSphereShape {
    void btSphereShape(float radius);
    float getRadius();
    void setUnscaledRadius(float radius);
    void setMargin(float margin);
    float getMargin();
};
btSphereShape implements btConvexInternalShape;

interface btConeShape {
    void btConeShape(float radius, float height);
};
btConeShape implements btConvexInternalShape;

interface btConvexHullShape {
    void btConvexHullShape([Const] optional float[] points, optional long numPoints, optional long stride);
    void addPoint([Const, Ref]btVector3 point, optional boolean recalculateLocalAABB);
    void setMargin(float margin);
    float getMargin();
    long getNumPoints();
    [Value]btVector3 getScaledPoint(long i);
    void optimizeConvexHull();
};
btConvexHullShape implements btPolyhedralConvexAabbCachingShape;

interface btConeShapeX {
    void btConeShapeX(float radius, float height);
};
btConeShapeX implements btConeShape;

interface btConeShapeZ {
    void btConeShapeZ(float radius, float height);
};
btConeShapeZ implements btConeShape;

interface btCompoundShape {
    void btCompoundShape(optional boolean enableDynamicAabbTree);
    void addChildShape([Const, Ref]btTransform localTransform, btCollisionShape shape);
    void removeChildShapeByIndex(long childShapeindex);
    void removeChildShape(btCollisionShape shape);
    [Const]long getNumChildShapes();
    btCollisionShape getChildShape(long index);
    void setMargin(float margin);
    float getMargin();
    void recalculateLocalAabb();
};
btCompoundShape implements btCollisionShape;

interface btConcaveShape {};
btConcaveShape implements btCollisionShape;

interface btStaticPlaneShape {
    void btStaticPlaneShape([Const, Ref]btVector3 planeNormal, float planeConstant);
};
btStaticPlaneShape implements btConcaveShape;

interface btTriangleMeshShape {};
btTriangleMeshShape implements btConcaveShape;

interface btBvhTriangleMeshShape {
    void btBvhTriangleMeshShape(btStridingMeshInterface meshInterface, boolean useQuantizedAabbCompression, optional boolean buildBvh);
    void btBvhTriangleMeshShape(btStridingMeshInterface meshInterface, boolean useQuantizedAabbCompression, [Const, Ref]btVector3 bvhAabbMin, [Const, Ref]btVector3 bvhAabbMax, optional boolean buildBvh);
    void performRaycast(btTriangleCallback callback, [Const, Ref]btVector3 raySource, [Const, Ref]btVector3 rayTarget);
};
btBvhTriangleMeshShape implements btTriangleMeshShape;

//interface btHeightfieldTerrainShape {
//    void btHeightfieldTerrainShape(long heightStickWidth, long heightStickLength, VoidPtr heightfieldData, float heightScale, float minHeight, float maxHeight, long upAxis, PHY_ScalarType hdt, boolean flipQuadEdges);
//    void setMargin(float margin);
//    float getMargin();
//};
//btHeightfieldTerrainShape implements btConcaveShape;

interface btScaledBvhTriangleMeshShape {
    void btScaledBvhTriangleMeshShape(btBvhTriangleMeshShape childShape, [Const, Ref]btVector3 localScaling);
};

interface btShapeHull {
    void btShapeHull(btConvexShape shape);
    long numTriangles();
    long numVertices();
    long numIndices();
    boolean buildHull(float margin);
};

// Other stuff

interface btIndexedMesh {
    void btIndexedMesh();
};

interface btTriangleMesh {
    void btTriangleMesh(optional boolean use32bitIndices, optional boolean use4componentVertices);
    void addTriangle([Const, Ref]btVector3 vertex0, [Const, Ref]btVector3 vertex1, [Const, Ref]btVector3 vertex2, optional boolean removeDuplicateVertices);
    void findOrAddVertex([Const, Ref]btVector3 vertex, boolean removeDuplicateVertices);
    void addIndex(long index);
};
btTriangleMesh implements btStridingMeshInterface;

interface btTriangleIndexVertexArray {
    void btTriangleIndexVertexArray();
    void setPremadeAabb([Const, Ref]btVector3 aabbMin, [Const, Ref]btVector3 aabbMax);
    void getPremadeAabb(btVector3 aabbMin, btVector3 aabbMax);
    boolean hasPremadeAabb();
//    void addIndexedMesh([Const, Ref]btIndexedMesh mesh, optional PHY_ScalarType indexType);
};
btTriangleIndexVertexArray implements btStridingMeshInterface;

interface btTriangleRaycastCallback {
    [Value]attribute btVector3 m_from;
    [Value]attribute btVector3 m_to;
    attribute float m_hitFraction;
    attribute unsigned long m_flags;
    float reportHit([Const, Ref]btVector3 hitNormalLocal, float hitFraction, long partId, long triangleIndex);
};
btTriangleRaycastCallback implements btTriangleCallback;

interface btTriangleCallback {
    void processTriangle(btVector3 triangle, long partId, long triangleIndex);
};

// Dynamics

interface btConstraintSetting {
    void btConstraintSetting();
    attribute float m_tau;
    attribute float m_damping;
    attribute float m_impulseClamp;
};

interface btGeneric6DofSpring2Constraint {
    void btGeneric6DofSpring2Constraint([Ref]btRigidBody rbA, [Ref]btRigidBody rbB, [Const, Ref]btTransform frameInA, [Const, Ref]btTransform frameInB);
    void setDbgDrawSize(float dbgDrawSize);
    void setLinearLowerLimit([Const, Ref]btVector3 linearLower);
    void setLinearUpperLimit([Const, Ref]btVector3 linearUpper);
    void setAngularLowerLimit([Const, Ref]btVector3 linearLower);
    void setAngularUpperLimit([Const, Ref]btVector3 linearUpper);
    void setLimit(long axis, float lo, float hi);
    void setStiffness(long index, float stiffness);
    void setDamping(long index, float damping);
    void setBounce(long index, float bounce);
    void setServo(long index, boolean onOff);
    void setServoTarget(long index, float target);
    void enableMotor(long index, boolean onOff);
    void enableSpring(long index, boolean onOff);
    void setTargetVelocity(long index, float velocity);
    void setMaxMotorForce(long index, float force);
    void setEquilibriumPoint();
    void setEquilibriumPoint(long index);
    void setEquilibriumPoint(long index, float val);
    void setFrames([Const, Ref]btTransform frameA, [Const, Ref]btTransform frameB);
    btRotationalLimitMotor2 getRotationalLimitMotor(long index);
    btTranslationalLimitMotor2 getTranslationalLimitMotor();
};
btGeneric6DofSpring2Constraint implements btTypedConstraint;

interface btRotationalLimitMotor2 {
    attribute float m_loLimit;
    attribute float m_hiLimit;
    attribute float m_bounce;
    attribute float m_stopERP;
    attribute float m_stopCFM;
    attribute float m_motorERP;
    attribute float m_motorCFM;
    attribute boolean m_enableMotor;
    attribute float m_targetVelocity;
    attribute float m_maxMotorForce;
    attribute boolean m_servoMotor;
    attribute float m_servoTarget;
    attribute boolean m_enableSpring;
    attribute float m_springStiffness;
    attribute boolean m_springStiffnessLimited;
    attribute float m_springDamping;
    attribute boolean m_springDampingLimited;
    attribute float m_equilibriumPoint;
    boolean isLimited();
    void testLimitValue(float test_value);
};

interface btTranslationalLimitMotor2 {
    [Value]attribute btVector3 m_lowerLimit;
    [Value]attribute btVector3 m_upperLimit;
    [Value]attribute btVector3 m_bounce;
    [Value]attribute btVector3 m_stopERP;
    [Value]attribute btVector3 m_stopCFM;
    [Value]attribute btVector3 m_motorERP;
    [Value]attribute btVector3 m_motorCFM;
//    attribute boolean [] m_enableMotor;
//    attribute boolean [] m_servoMotor;
//    attribute boolean [] m_enableSpring;
    [Value]attribute btVector3 m_servoTarget;
    [Value]attribute btVector3 m_springStiffness;
//    attribute boolean [] m_springStiffnessLimited;
    [Value]attribute btVector3 m_springDamping;
//    attribute boolean [] m_springDampingLimited;
    [Value]attribute btVector3 m_equilibriumPoint;
    [Value]attribute btVector3 m_targetVelocity;
    [Value]attribute btVector3 m_maxMotorForce;
    boolean isLimited(long limitIndex);
    void testLimitValue(long limitIndex, float test_value);
};

interface btFixedConstraint {
    void btFixedConstraint([Ref]btRigidBody rbA, [Ref]btRigidBody rbB, [Const, Ref]btTransform frameInA, [Const, Ref]btTransform frameInB);
};
btFixedConstraint implements btTypedConstraint;

interface btPoint2PointConstraint {
    void btPoint2PointConstraint([Ref]btRigidBody rbA, [Ref]btRigidBody rbB, [Ref]btVector3 pivotInA, [Ref]btVector3 pivotInB);
    void btPoint2PointConstraint([Ref]btRigidBody rbA, [Ref]btVector3 pivotInA);
    void setPivotA([Const, Ref]btVector3 pivotA);
    void setPivotB([Const, Ref]btVector3 pivotB);
    [Const, Ref]btVector3 getPivotInA();
    [Const, Ref]btVector3 getPivotInB();
    [Value]attribute btConstraintSetting m_setting;
};
btPoint2PointConstraint implements btTypedConstraint;

interface btGeneric6DofConstraint {
    void btGeneric6DofConstraint([Ref]btRigidBody rbA, [Ref]btRigidBody rbB, [Ref]btTransform frameInA, [Ref]btTransform frameInB, boolean useLinearFrameReferenceFrameA);
    void btGeneric6DofConstraint([Ref]btRigidBody rbB, [Ref]btTransform frameInB, boolean useLinearFrameReferenceFrameB);
    void setLinearLowerLimit([Const, Ref]btVector3 linearLower);
    void setLinearUpperLimit([Const, Ref]btVector3 linearUpper);
    void setAngularLowerLimit([Const, Ref]btVector3 angularLower);
    void setAngularUpperLimit([Const, Ref]btVector3 angularUpper);
};
btGeneric6DofConstraint implements btTypedConstraint;

interface btGeneric6DofSpringConstraint {
    void btGeneric6DofSpringConstraint([Ref]btRigidBody rbA, [Ref]btRigidBody rbB, [Ref]btTransform frameInA, [Ref]btTransform frameInB, boolean useLinearFrameReferenceFrameA);
    void btGeneric6DofSpringConstraint([Ref]btRigidBody rbB, [Ref]btTransform frameInB, boolean useLinearFrameReferenceFrameB);
    void enableSpring(long index, boolean onOff);
    void setStiffness(long index, float stiffness);
    void setDamping(long index, float damping);
};
btGeneric6DofSpringConstraint implements btGeneric6DofConstraint;

interface btConeTwistConstraint {
    void btConeTwistConstraint([Ref]btRigidBody rbA, [Ref]btRigidBody rbB, [Ref]btTransform rbAFrame, [Ref]btTransform rbBFrame);
    void btConeTwistConstraint([Ref]btRigidBody rbA, [Ref]btTransform rbAFrame);
    void setLimit(long limitIndex, float limitValue);
    void setLimit(float _swingSpan1, float _swingSpan2, float _twistSpan, optional float _softness, optional float _biasFactor, optional float _relaxationFactor);
    void setAngularOnly(boolean angularOnly);
    void setDamping(float damping);
    void enableMotor(boolean b);
    void setMaxMotorImpulse(float maxMotorImpulse);
    void setMaxMotorImpulseNormalized(float maxMotorImpulse);
    void setMotorTarget([Const, Ref]btQuaternion q);
    void setMotorTargetInConstraintSpace([Const, Ref]btQuaternion q);
};
btConeTwistConstraint implements btTypedConstraint;

interface btHingeConstraint {
    void btHingeConstraint([Ref]btRigidBody rbA, [Ref]btRigidBody rbB, [Const, Ref]btVector3 pivotInA, [Const, Ref]btVector3 pivotInB, [Const, Ref]btVector3 axisInA, [Const, Ref]btVector3 axisInB, optional boolean useReferenceFrameA);
    void btHingeConstraint([Ref]btRigidBody rbA, [Ref]btVector3 pivotInA, [Const, Ref]btVector3 axisInA, boolean useReferenceFrameA);
    void btHingeConstraint([Ref]btRigidBody rbA, [Ref]btRigidBody rbB, [Const, Ref]btTransform rbAFrame, [Const, Ref]btTransform rbBFrame, boolean useReferenceFrameA);
    void btHingeConstraint([Ref]btRigidBody rbA, [Const, Ref]btTransform rbAFrame, boolean useReferenceFrameA);
    void setLimit(float low, float high, optional float softness, optional float biasFactor, optional float relaxationFactor);
    void enableAngularMotor(boolean enableMotor, float targetVelocity, float maxMotorImpulse);
};
btHingeConstraint implements btTypedConstraint;

interface btSliderConstraint {
    void btSliderConstraint([Ref]btRigidBody rbA, [Ref]btRigidBody rbB, [Const, Ref]btTransform frameInA, [Const, Ref]btTransform frameInB, boolean useLinearReferenceFrameA);
    void btSliderConstraint([Ref]btRigidBody rbB, [Const, Ref]btTransform frameInB, boolean uesLinearReferenceFrameA);
    void setLowerLinLimit(float lowerLimit);
    void setUpperLinLimit(float upperLimit);
    void setLowerAngLimit(float lowerAngLimit);
    void setUpperAngLimit(float upperAngLimit);
};
btSliderConstraint implements btTypedConstraint;

interface btDispatcherInfo {
    attribute float m_timeStep;
    attribute long m_stepCount;
    attribute long m_dispatchFunc;
    attribute float m_timeOfImpact;
    attribute boolean m_useContinuous;
    attribute boolean m_enableSatConvex;
    attribute boolean m_enableSPU;
    attribute boolean m_useEpa;
    attribute float m_allowedCcdPenetration;
    attribute boolean m_useConvexConservativeDistanceUtil;
    attribute float m_convexConservativeDistanceThreshold;
};

//Vehicle

[Prefix = "btRaycastVehicle::"]
interface btVehicleTuning {
    void btVehicleTuning();
    attribute float m_suspensionStiffness;
    attribute float m_suspensionCompression;
    attribute float m_suspensionDamping;
    attribute float m_maxSuspensionTravelCm;
    attribute float m_frictionSlip;
    attribute float m_maxSuspensionForce;
};

interface btVehicleRaycaster {};

interface btDefaultVehicleRaycaster {
    void btDefaultVehicleRaycaster(btDynamicsWorld world);
};
btDefaultVehicleRaycaster implements btVehicleRaycaster;

[Prefix = "btWheelInfo::"]
interface RaycastInfo {
    void RaycastInfo();
    [Value]attribute btVector3 m_contactNormalWS;
    [Value]attribute btVector3 m_contactPointWS;
    attribute float m_suspensionLength;
    [Value]attribute btVector3 m_hardPointWS;
    [Value]attribute btVector3 m_wheelDirectionWS;
    [Value]attribute btVector3 m_wheelAxleWS;
    attribute boolean m_isInContact;
    attribute any m_groundObject;
};

interface btWheelInfo {
    [Value]attribute RaycastInfo m_raycastInfo;
    [Value]attribute btTransform m_worldTransform;
    [Value]attribute btVector3 m_chassisConnectionPointCS;
    [Value]attribute btVector3 m_wheelDirectionCS;
    [Value]attribute btVector3 m_wheelAxleCS;
    attribute float m_suspensionRestLength1;
    attribute float m_maxSuspensionTravelCm;
    attribute float m_wheelsRadius;
    attribute float m_suspensionStiffness;
    attribute float m_wheelsDampingCompression;
    attribute float m_wheelsDampingRelaxation;
    attribute float m_frictionSlip;
    attribute float m_steering;
    attribute float m_rotation;
    attribute float m_deltaRotation;
    attribute float m_rollInfluence;
    attribute float m_maxSuspensionForce;
    attribute float m_engineForce;
    attribute float m_brake;
    attribute boolean m_bIsFrontWheel;
    attribute float m_clippedInvContactDotSuspension;
    attribute float m_suspensionRelativeVelocity;
    attribute float m_wheelsSuspensionForce;
    attribute float m_skidInfo;
    void updateWheel([Const, Ref]btRigidBody chassis, [Ref]RaycastInfo raycastInfo);
};

interface btRaycastVehicle {
    void btRaycastVehicle([Const, Ref]btVehicleTuning tuning, btRigidBody chassis, btVehicleRaycaster raycaster);
    void applyEngineForce(float force, long wheel);
    void updateVehicle(float step);
    void resetSuspension();
    float rayCast([Ref]btWheelInfo wheel);
    float getSteeringValue(long wheel);
    void setSteeringValue(float steering, long wheel);
    [Const, Ref]btTransform getWheelTransformWS(long wheelIndex);
    void updateWheelTransform(long wheelIndex, optional boolean interpolatedTransform);
    void updateWheelTransformsWS([Ref]btWheelInfo wheel, optional boolean interpolatedTransform);
    [Ref]btWheelInfo addWheel([Const, Ref]btVector3 connectionPointCS0, [Const, Ref]btVector3 wheelDirectionCS0, [Const, Ref]btVector3 wheelAxleCS, float suspensionRestLength, float wheelRadius, [Const, Ref]btVehicleTuning tuning, boolean isFrontWheel);
    long getNumWheels();
    btRigidBody getRigidBody();
    [Ref]btWheelInfo getWheelInfo(long index);
    void setBrake(float brake, long wheelIndex);
    void setCoordinateSystem(long rightIndex, long upIndex, long forwardIndex);
    float getCurrentSpeedKmHour();
    long getRightAxis();
    long getUpAxis();
    long getForwardAxis();
    [Value]btVector3 getForwardVector();
    long getUserConstraintType();
    void setUserConstraintType(long userConstraintType);
    void setUserConstraintId(long uid);
    long getUserConstraintId();
    void updateFriction(float timeStep);
    void updateSuspension(float deltaTime);
    void setPitchControl(float pitch);
};
btRaycastVehicle implements btActionInterface;

interface btKinematicCharacterController {
    void btKinematicCharacterController(btPairCachingGhostObject ghostObject, btConvexShape convexShape, float stepHeight, [Ref] optional btVector3 upAxis);
    void setUp([Const, Ref]btVector3 up);
    void setWalkDirection([Const, Ref]btVector3 walkDirection);
    void setVelocityForTimeInterval([Const, Ref]btVector3 velocity, float timeInterval);
    //void reset ();
    void warp([Const, Ref]btVector3 origin);
    void preStep(btCollisionWorld collisionWorld);
    void playerStep(btCollisionWorld collisionWorld, float dt);
    void setFallSpeed(float fallSpeed);
    void setJumpSpeed(float jumpSpeed);
    void setMaxJumpHeight(float maxJumpHeight);
    boolean canJump();
    void jump([Const, Ref]optional btVector3 v);
    void setGravity([Const, Ref]btVector3 gravity);
    [Value]btVector3 getGravity();
    void setMaxSlope(float slopeRadians);
    float getMaxSlope();
    btPairCachingGhostObject getGhostObject();
    void setUseGhostSweepTest(boolean useGhostObjectSweepTest);
    boolean onGround();
};
btKinematicCharacterController implements btActionInterface;

interface btGhostObject {
    void btGhostObject();
    long getNumOverlappingObjects();
    btCollisionObject getOverlappingObject(long index);
};
btGhostObject implements btCollisionObject;

interface btPairCachingGhostObject {
    void btPairCachingGhostObject();
};
btPairCachingGhostObject implements btGhostObject;

interface btGhostPairCallback {
    void btGhostPairCallback();
};

//  Soft bodies

// interface btSparseSdf3 {
// void Initialize(btSoftBodyWorldInfo worldInfo, optional long hashsize, optional long clampCells);
// void Reset(btSoftBodyWorldInfo worldInfo);
// void GarbageCollect(btSoftBodyWorldInfo  worldInfo, optional long lifetime);
// };

interface btSoftBodyWorldInfo {
    void btSoftBodyWorldInfo();
    attribute float air_density;
    attribute float water_density;
    attribute float water_offset;
    attribute float m_maxDisplacement;
    [Value]attribute btVector3 water_normal;
    attribute btBroadphaseInterface m_broadphase;
    attribute btDispatcher m_dispatcher;
    [Value]attribute btVector3 m_gravity;
};

//[Prefix = "btSoftBody::"]
//interface tNodeArray {
//    void tNodeArray();
//    [Const]long size();
//    [Const, Ref]Node at(long n);
//    void resize(long numVertices);
//};
//
//[Prefix = "btSoftBody::"]
//interface tFaceArray {
//    void tFaceArray();
//    [Const]long size();
//    [Const, Ref]Face at(long n);
//};
//
//[Prefix = "btSoftBody::"]
//interface Node {
//    [Value]attribute btVector3 m_x;
//    [Value]attribute btVector3 m_q;
//    [Value]attribute btVector3 m_v;
//    [Value]attribute btVector3 m_f;
//    [Value]attribute btVector3 m_n;
//    attribute float m_im;
//    attribute float m_area;
//};

//[Prefix = "btSoftBody::"]
//interface Face {
//    // [Value] attribute Node  m_n;
//    [Value]attribute btVector3 m_normal;
//    attribute float m_ra;
//};

//[Prefix = "btSoftBody::"]
//interface Element {
//    attribute any m_tag;
//};

//[Prefix = "btSoftBody::"]
//interface Material {
//    attribute float m_kLST;
//    attribute float m_kAST;
//    attribute float m_kVST;
//    attribute long m_flags;
//};
//Material implements Element;

//[Prefix = "btSoftBody::"]
//interface tMaterialArray {
//    void tMaterialArray();
//    [Const]long size();
//    Material at(long n);
//};

[Prefix = "btSoftBody::"]
interface Config {
    void Config();
    attribute float kVCF;
    attribute float kDP;
    attribute float kDG;
    attribute float kLF;
    attribute float kPR;
    attribute float kVC;
    attribute float kDF;
    attribute float kMT;
    attribute float kCHR;
    attribute float kKHR;
    attribute float kSHR;
    attribute float kAHR;
    attribute float kSRHR_CL;
    attribute float kSKHR_CL;
    attribute float kSSHR_CL;
    attribute float kSR_SPLT_CL;
    attribute float kSK_SPLT_CL;
    attribute float kSS_SPLT_CL;
    attribute float maxvolume;
    attribute float timescale;
    attribute long viterations;
    attribute long piterations;
    attribute long diterations;
    attribute long citerations;
    attribute long collisions;
};

interface btSoftBody {
    void btSoftBody(btSoftBodyWorldInfo worldInfo); //, long node_count, [Const] btVector3 x, [Const] long m);

//    [Value]attribute Config m_cfg;
//    [Value]attribute tNodeArray m_nodes;
//    [Value]attribute tFaceArray m_faces;
//    [Value]attribute tMaterialArray m_materials;

    [Const]boolean checkLink(long node0, long node1);
    [Const]boolean checkFace(long node0, long node1, long node2);
//    Material appendMaterial();
    void appendNode([Const, Ref]btVector3 x, float m);
//    void appendLink(long node0, long node1, Material mat, boolean bcheckexist);
//    void appendFace(long node0, long node1, long node2, Material mat);
//    void appendTetra(long node0, long node1, long node2, long node3, Material mat);
    void appendAnchor(long node, btRigidBody body, boolean disableCollisionBetweenLinkedBodies, float influence);
    [Const]float getTotalMass();
    void setTotalMass(float mass, optional boolean fromfaces);
    void setMass(long node, float mass);
    void transform([Const, Ref]btTransform trs);
    void translate([Const, Ref]btVector3 trs);
    void rotate([Const, Ref]btQuaternion rot);
    void scale([Const, Ref]btVector3 scl);
    long generateClusters(long k, optional long maxiterations);
    void randomizeConstraints();
//    long generateBendingConstraints(long distance, optional Material mat);
    btSoftBody upcast(btCollisionObject colObj);
};
btSoftBody implements btCollisionObject;

interface btSoftBodyRigidBodyCollisionConfiguration {
    void btSoftBodyRigidBodyCollisionConfiguration([Ref]optional btDefaultCollisionConstructionInfo info);  // Not allowing to build
};
btSoftBodyRigidBodyCollisionConfiguration implements btDefaultCollisionConfiguration;

interface btSoftBodySolver {};

interface btDefaultSoftBodySolver {
    void btDefaultSoftBodySolver(); // Not allowing to build
};
btDefaultSoftBodySolver implements btSoftBodySolver;

interface btSoftBodyArray {
    [Const]long size();
    [Const]btSoftBody at(long n);
};

interface btSoftRigidDynamicsWorld {
    void btSoftRigidDynamicsWorld(btDispatcher dispatcher, btBroadphaseInterface pairCache, btConstraintSolver constraintSolver, btCollisionConfiguration collisionConfiguration, optional btSoftBodySolver softBodySolver);
    void addSoftBody(btSoftBody body, optional long collisionFilterGroup, optional long collisionFilterMask);
    void removeSoftBody(btSoftBody body);
    [Ref]btSoftBodyWorldInfo getWorldInfo();
    [Ref]btSoftBodyArray getSoftBodyArray();
    long getDrawFlags();
    void setDrawFlags(long f);
};
btSoftRigidDynamicsWorld implements btDiscreteDynamicsWorld;

// interface btMultiBody {

// };

// interface btMultiBodyLinkCollider {
// void btMultiBodyLinkCollider(btMultiBody multiBody, long link);

// };
// btMultiBodyLinkCollider implements btCollisionObject;

// interface btMultiBodyConstraintSolver {

// };
// btMultiBodyConstraintSolver implements btSequentialImpulseConstraintSolver;

// interface btMultiBodyDynamicsWorld {
// void btMultiBodyDynamicsWorld(btDispatcher dispatcher, btBroadphaseInterface pairCache, btMultiBodyConstraintSolver constraintSolver, btCollisionConfiguration collisionConfiguration);


// };
// btMultiBodyDynamicsWorld implements btDiscreteDynamicsWorld;
//
//interface btSoftBodyHelpers {
//    void btSoftBodyHelpers();
//    btSoftBody CreateRope([Ref]btSoftBodyWorldInfo worldInfo, [Const, Ref]btVector3 from, [Const, Ref]btVector3 to, long res, long fixeds);
//    btSoftBody CreatePatch([Ref]btSoftBodyWorldInfo worldInfo, [Const, Ref]btVector3 corner00, [Const, Ref]btVector3 corner10, [Const, Ref]btVector3 corner01, [Const, Ref]btVector3 corner11, long resx, long resy, long fixeds, boolean gendiags);
//    // btSoftBody CreatePatchUV([Ref] btSoftBodyWorldInfo worldInfo, [Const, Ref] btVector3 corner00, [Const, Ref] btVector3 corner10, [Const, Ref] btVector3 corner01, [Const, Ref] btVector3 corner11, long resx, long resy, long fixeds, boolean gendiags, float[] tex_coords);
//    btSoftBody CreateEllipsoid([Ref]btSoftBodyWorldInfo worldInfo, [Const, Ref]btVector3 center, [Const, Ref]btVector3 radius, long res);
//    // btSoftBody CreateFromTriMesh([Ref] btSoftBodyWorldInfo worldInfo, float[] vertices, long[] triangles, long ntriangles, boolean randomizeConstraints);
//    btSoftBody CreateFromConvexHull([Ref]btSoftBodyWorldInfo worldInfo, [Const]btVector3 vertices, long nvertices, boolean randomizeConstraints);
//};

enum PHY_ScalarType {
    "PHY_FLOAT",
    "PHY_DOUBLE",
    "PHY_INTEGER",
    "PHY_SHORT",
    "PHY_FIXEDPOINT88",
    "PHY_UCHAR"
};

enum DebugDrawModes {
    "btIDebugDraw::DBG_NoDebug",
    "btIDebugDraw::DBG_DrawWireframe",
    "btIDebugDraw::DBG_DrawAabb",
    "btIDebugDraw::DBG_DrawFeaturesText",
    "btIDebugDraw::DBG_DrawContactPoints",
    "btIDebugDraw::DBG_NoDeactivation",
    "btIDebugDraw::DBG_NoHelpText",
    "btIDebugDraw::DBG_DrawText",
    "btIDebugDraw::DBG_ProfileTimings",
    "btIDebugDraw::DBG_EnableSatComparison",
    "btIDebugDraw::DBG_DisableBulletLCP",
    "btIDebugDraw::DBG_EnableCCD",
    "btIDebugDraw::DBG_DrawConstraints",
    "btIDebugDraw::DBG_DrawConstraintLimits",
    "btIDebugDraw::DBG_FastWireframe",
    "btIDebugDraw::DBG_DrawNormals",
    "btIDebugDraw::DBG_DrawFrames",
    "btIDebugDraw::DBG_MAX_DEBUG_DRAW_MODE"
};

enum CollisionFlags {
    "btCollisionObject::CF_DYNAMIC_OBJECT",
    "btCollisionObject::CF_STATIC_OBJECT",
    "btCollisionObject::CF_KINEMATIC_OBJECT",
    "btCollisionObject::CF_NO_CONTACT_RESPONSE",
    "btCollisionObject::CF_CUSTOM_MATERIAL_CALLBACK",
    "btCollisionObject::CF_CHARACTER_OBJECT",
    "btCollisionObject::CF_DISABLE_VISUALIZE_OBJECT",
    "btCollisionObject::CF_DISABLE_SPU_COLLISION_PROCESSING",
    "btCollisionObject::CF_HAS_CONTACT_STIFFNESS_DAMPING",
    "btCollisionObject::CF_HAS_CUSTOM_DEBUG_RENDERING_COLOR",
    "btCollisionObject::CF_HAS_FRICTION_ANCHOR",
    "btCollisionObject::CF_HAS_COLLISION_SOUND_TRIGGER"
};

enum CollisionObjectTypes {
    "btCollisionObject::CO_COLLISION_OBJECT",
    "btCollisionObject::CO_RIGID_BODY",
    "btCollisionObject::CO_GHOST_OBJECT",
    "btCollisionObject::CO_SOFT_BODY",
    "btCollisionObject::CO_HF_FLUID",
    "btCollisionObject::CO_USER_TYPE",
    "btCollisionObject::CO_FEATHERSTONE_LINK"
};

enum AnisotropicFrictionFlags {
    "btCollisionObject::CF_ANISOTROPIC_FRICTION_DISABLED",
    "btCollisionObject::CF_ANISOTROPIC_FRICTION",
    "btCollisionObject::CF_ANISOTROPIC_ROLLING_FRICTION"
};

enum BroadphaseNativeTypes {
    "BOX_SHAPE_PROXYTYPE",
    "TRIANGLE_SHAPE_PROXYTYPE",
    "TETRAHEDRAL_SHAPE_PROXYTYPE",
    "CONVEX_TRIANGLEMESH_SHAPE_PROXYTYPE",
    "CONVEX_HULL_SHAPE_PROXYTYPE",
    "CONVEX_POINT_CLOUD_SHAPE_PROXYTYPE",
    "CUSTOM_POLYHEDRAL_SHAPE_TYPE",
    "IMPLICIT_CONVEX_SHAPES_START_HERE",
    "SPHERE_SHAPE_PROXYTYPE",
    "MULTI_SPHERE_SHAPE_PROXYTYPE",
    "CAPSULE_SHAPE_PROXYTYPE",
    "CONE_SHAPE_PROXYTYPE",
    "CONVEX_SHAPE_PROXYTYPE",
    "CYLINDER_SHAPE_PROXYTYPE",
    "UNIFORM_SCALING_SHAPE_PROXYTYPE",
    "MINKOWSKI_SUM_SHAPE_PROXYTYPE",
    "MINKOWSKI_DIFFERENCE_SHAPE_PROXYTYPE",
    "BOX_2D_SHAPE_PROXYTYPE",
    "CONVEX_2D_SHAPE_PROXYTYPE",
    "CUSTOM_CONVEX_SHAPE_TYPE",
    "CONCAVE_SHAPES_START_HERE",
    "TRIANGLE_MESH_SHAPE_PROXYTYPE",
    "SCALED_TRIANGLE_MESH_SHAPE_PROXYTYPE",
    "FAST_CONCAVE_MESH_PROXYTYPE",
    "TERRAIN_SHAPE_PROXYTYPE",
    "GIMPACT_SHAPE_PROXYTYPE",
    "MULTIMATERIAL_TRIANGLE_MESH_PROXYTYPE",
    "EMPTY_SHAPE_PROXYTYPE",
    "STATIC_PLANE_PROXYTYPE",
    "CUSTOM_CONCAVE_SHAPE_TYPE",
    "CONCAVE_SHAPES_END_HERE",
    "COMPOUND_SHAPE_PROXYTYPE",
    "SOFTBODY_SHAPE_PROXYTYPE",
    "HFFLUID_SHAPE_PROXYTYPE",
    "HFFLUID_BUOYANT_CONVEX_SHAPE_PROXYTYPE",
    "INVALID_SHAPE_PROXYTYPE",
    "MAX_BROADPHASE_COLLISION_TYPES"
};